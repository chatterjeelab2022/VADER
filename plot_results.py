"""@author: Rachel Kelemen@deputy wizard: Joshua BrownFinalized April 2019This module contains a function which plots the results of a sequencing run in various ways using matplotlib and the weblogo function from biopython."""from v2_plotting_tools import scatter_plot, bar_chart, stacked_bar_chart, heat_mapimport osimport matplotlib.pyplot as pltimport numpy as npfrom Bio import motifsfrom Bio.Seq import Seqfrom Bio.Alphabet import IUPACdef weblogo(fig_file_address, sequence_holder):    """A utility function to make weblogos using the Bio.motifs module    Parameters    ---    fig_file_address : str        Address where the resulting figure should be stored sequence_holder : list        A list of biopython sequence objects    Notes    ---    Saves a weblogo at the given file address using my defaut settings for visualizing short RNA sequences.    """    # Make sure sequence_holder contains at least one sequence    if len(sequence_holder) > 0:        # Make a biopython Motif object from the sequences in sequence_holder        m = motifs.create(sequence_holder)        # Make a weblogo by probability (aka fraction of each base)        m.weblogo(fig_file_address, unit_name='probability', show_fineprint=False,            show_xaxis=False, scale_width=False, stack_width='large', color_scheme='color_custom', symbols0='A', color0='green', symbols1='C', color1='blue', symbols2='G', color2='black', symbols3='U', color3='red',)    else:        print('Weblogo error: sequence_holder is empty')def plot_results(working_folder_name, sequence_table, low_abundance_table, biosamples,                  randomized_bases, sel_1_name, sel_2_name, sel_2_runs, expected_pairs):    """A function which plots the results of a selection.    Parameters    ---    working_folder_name : str       Working folder    sequence_table : list        A table containing the results of count_randomized_sequences and calculate_enrichments    low_abundance_table : list        A table containing the low abundance sequences from count_randomized_sequences and calculate_enrichments    biosamples : list        List of biosamples    randomized_bases : list        Randomized base coordinates - used to determine how many there are    sel_1_name : str        Selection condition 1    sel_2_name : str        Selection condition 2    expected_pairs : list        Randomized base pairs rand_expected_pairs    Notes    ---    All series of binned plots also include the full pool for comparison.    Plots generated    ---    Describing initial library characteristics        Plot : library abundance VS library rank        Weblogo : 1 % most abundant sequences        Weblogo : 1 % least abundant sequences including not observed        Weblogo : All low abundance sequences    Describing enrichment (ignores low abundance sequences)        Weblogos : Bin % most enriched        Weblogos : Bin % least enriched        Weblogos : Each 10% of the library        Plots : enrichment factor VS enrichment rank (each individual and average value, incorporate individual values onto standard plot with low alpha)    Repeat all of these for fully base paired sequences    Describing base pairing        Stacked bar : Fraction of sequences with N pairs, by bin        Bars : Histogram of frequency of each pair type by sequence, by bin        Repeat this for fully base paired sequences        Plots : enrichment factor VS enrichment rank (average value, low alpha on separate plots by number of pairs)    Comparing different selection runs        Plots : enrichment factor 1 VS enrichment factor 2 for each pairwise selection combo        Plot : average sel 1 enrichment factor VS average sel 2 enrichment factor    """    # Setup    # Set up column indices from calculate_enrichments.    # Some might get flagged that they're assigned but unused - that's fine.    (Randomized_sequence, Full_stem_sequence, Paired_bases,      Raw_counts, Fraction_of_total,      Fold_enrichment, Enrichment_factor, Enrichment_rank,      Avg_enrichment_factor, Stdev, Avg_rank) = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)    # Make the plot folders    plot_folder = working_folder_name + '//Plots//Results'    sub_folders = ['//Library distribution', '//Enrichment', '//Base pairing',                    '//Compare selections', '//Weblogo']    for sub_folder in sub_folders:        if os.path.exists(plot_folder + sub_folder) == False:            os.makedirs(plot_folder + sub_folder)              # Plotting requires several different sequence lists    # lib_sorted_sequence_table : contains all sequences, high and low abundance,  sorted by library abundance    # sorted_sequence_table : contains abundant sequences, sorted by average enrichment    # paired_sequence_table : contains fully base paired sequences, sorted by average enrichment            print('> Generating sorted tables for plotting')    # lib_sorted_sequence_table    # lib_size is generated from this table    lib_sorted_sequence_table = sorted(sequence_table, key = lambda x: x[Fraction_of_total][0], reverse=True)    lib_sorted_low_abundance_table = sorted(low_abundance_table, key =lambda x: x[Fraction_of_total][0], reverse=True)    for sequence_data in lib_sorted_low_abundance_table:        lib_sorted_sequence_table.append(sequence_data)    lib_size = len(lib_sorted_sequence_table)    # sorted_sequence_table    sorted_sequence_table = sorted(sequence_table, key = lambda x: x[Avg_enrichment_factor][- 1], reverse=True)    # paired_sequence_table    paired_sequence_table = []    for sequence_data in sorted_sequence_table:        if sequence_data[Paired_bases][0] == len(expected_pairs):            paired_sequence_table.append(sequence_data)    paired_size = len(paired_sequence_table)    print('> Plotting library distribution')    # Plots describing initial library characteristics    # library count VS library rank and    # library abundance VS library rank    # y values    lib_counts = []    lib_abundances = []    for sequence_data in lib_sorted_sequence_table:        lib_counts.append(sequence_data[Raw_counts][0])        lib_abundances.append(sequence_data[Fraction_of_total][0])    # x values    lib_ranks = np.arange(len(lib_abundances))    # Make plots    for y_data, y_label in zip([lib_counts, lib_abundances], ['Count', 'Abundance']):        fig, ax = plt.subplots(figsize=(6,4))        ax.plot(lib_ranks, y_data, marker='o', linestyle='', markeredgewidth=0)        ax.grid(axis='y', color='0.5')        ax.set_xlabel('Rank')        ax.set_ylabel(y_label)        ax.set_title('Library distribution')        plt.tight_layout        # Save        fig_file_name = '//Library distribution ' + y_label + '.png'        fig_file_address = plot_folder + '//Library distribution' + fig_file_name         plt.savefig(fig_file_address, dpi=300)        # Log version        ax.set_yscale('log')        plt.tight_layout        fig_file_name = '//Library distribution ' + y_label + ' log.png'        fig_file_address = plot_folder + '//Library distribution' + fig_file_name        plt.savefig(fig_file_address, dpi=300)        plt.close()        print('> Generating weblogos by library abundance')    # Weblogos for most and least abundant sequences    # All sequences and fully base paired sequences    # A weblogo for the full library, for comparison    sequence_holder = []    for sequence_data in lib_sorted_sequence_table:        # Extract randomized sequence and remove /s        sequence = sequence_data[Randomized_sequence][0].replace('/ ','')        # Convert to a Biopython Seq object and add to sequence_holder        sequence_holder.append(Seq(sequence, IUPAC.unambiguous_rna))        # Make weblogo    fig_file_name = '//Library all sequences.png'    fig_file_address = plot_folder + '//Library distribution' + fig_file_name    weblogo(fig_file_address, sequence_holder)    # Top and bottom 0.1% and 1%    bins = [0.01]    for b in bins:        # Number of sequences in the bin        c = int(b*lib_size)        most_abundant = lib_sorted_sequence_table[:c]        least_abundant = lib_sorted_sequence_table[-c:]        for binned, title in zip([most_abundant, least_abundant], ['Top', 'Bottom']):            sequence_holder = []            for sequence_data in binned:                sequence = sequence_data[Randomized_sequence][0].replace('/ ','')                sequence_holder.append(Seq(sequence, IUPAC.unambiguous_rna))            # Make weblogo        fig_file_name = '//Library ' + title + ' {} sequences.png'.format(c)        fig_file_address = plot_folder + '//Library distribution' + fig_file_name        weblogo(fig_file_address, sequence_holder)            # Low abundance or not observed    not_observed_holder = []    low_abundance_holder = []    for sequence_data in lib_sorted_low_abundance_table:        # Check if low abundance or not observed        if sequence_data[Raw_counts][0] == 0:            sequence = sequence_data[Randomized_sequence][0].replace('/ ','')            not_observed_holder.append(Seq(sequence, IUPAC.unambiguous_rna))        else:            sequence = sequence_data[Randomized_sequence][0].replace('/ ','')            low_abundance_holder.append(Seq(sequence, IUPAC.unambiguous_rna))    # Not observed weblogo    if len(not_observed_holder) > 0:        fig_file_name = '//Not observed {}.png'.format(len(not_observed_holder))        fig_file_address = plot_folder + '//Library distribution' + fig_file_name        weblogo(fig_file_address, not_observed_holder)    # Low abundance weblogo    if len(not_observed_holder) > 0:        fig_file_name = '//Low abundance {}.png'.format(len(low_abundance_holder))        fig_file_address = plot_folder + '//Library distribution' + fig_file_name        weblogo(fig_file_address, low_abundance_holder)            print('> Generating weblogos by enrichment')    # Weblogos by enrichment    # Bin from 0.01% to 10%    bins = [0.0001, 0.0003, 0.001, 0.003, 0.01, 0.03, 0.1]    for table, folder, size in zip([sorted_sequence_table, paired_sequence_table],                                    [plot_folder + '//Weblogo'],                                    [lib_size, paired_size]):        for b in bins:            # Calculate bin size based on whole library, even though some sequences were             # low abundance.            c = int(b * size)            # Only plot if there's more than one sequence in the bin            if c > 4:                most_abundant = table[:c]                least_abundant = table[-c:]                for binned, title in zip([most_abundant, least_abundant], ['Top', 'Bottom']):                    sequence_holder = []                    for sequence_data in binned:                        sequence = sequence_data[Randomized_sequence][0].replace('/ ','')                        sequence_holder.append(Seq(sequence, IUPAC.unambiguous_rna))                    # Make weblogo                    fig_file_name = '//' + title + ' {:.2f}pct n{} sequences.png'.format(b*100, c)                    fig_file_address = folder + '//' + fig_file_name                    weblogo(fig_file_address, sequence_holder)                            # By 10% blocks        b = 0.1        # Block size - round up        c = int(b*len(table)) + 1        # Loop through blocks        lower_limit = 0        while lower_limit < len(table):            upper_limit = lower_limit + c            if upper_limit > len(table):                upper_limit = len(table)            for sequence_data in table[lower_limit:upper_limit]:                sequence = sequence_data[Randomized_sequence][0].replace('/ ','')                sequence_holder.append(Seq(sequence, IUPAC.unambiguous_rna))            # Make weblogo            fig_file_name = '// 10pct block {} to {}.png'.format(lower_limit, upper_limit)             fig_file_address = folder + '//' + fig_file_name            weblogo(fig_file_address, sequence_holder)            # Clear and go to the next block            sequence_holder.clear()            lower_limit += c        print('> Plotting enrichment versus rank')    # Plot enrichment factor versus enrichment rank for all selections and averages.    # Individual selections    for i in np.arange(1, len(biosamples)):        enrichment_factors = []        ranks = []        for sequence_data in sorted_sequence_table:            enrichment_factors.append(sequence_data[Enrichment_factor][i])            ranks.append(sequence_data[Enrichment_rank][i])        # make plot        fig, ax = plt.subplots(figsize=(6,4))        ax.plot(ranks, enrichment_factors, marker='o', linestyle='', markeredgewidth=0)        ax.grid(axis='y', color='0.5')        ax.set_xlabel('Rank')        ax.set_ylabel('Enrichment factor')        ax.set_title(biosamples[i])        plt.tight_layout        # Save        fig_file_name = '//Enrichment factor vs rank ' + biosamples[i] + '.png'        fig_file_address = plot_folder + '//Enrichment' + fig_file_name        plt.savefig(fig_file_address, dpi=300)        plt.close()            # Averages    # If two types of selections    if sel_2_runs:        for i, name in zip([0, 1, 2], [sel_1_name, sel_2_name, 'All selections']):            enrichment_factors = []            ranks = []            for sequence_data in sorted_sequence_table:                enrichment_factors.append(sequence_data[Avg_enrichment_factor][i])                ranks.append(sequence_data[Avg_rank][i])            # make plot            fig, ax = plt.subplots(figsize=(6,4))            ax.plot(ranks, enrichment_factors, marker='o', linestyle='', markeredgewidth=0)            ax.grid(axis='y', color='0.5')            ax.set_xlabel('Rank')            ax.set_ylabel('Average enrichment factor')            ax.set_title(name)            plt.tight_layout            # Save            fig_file_name = '//Average enrichment factor vs rank ' + name + '.png'            fig_file_address = plot_folder + '//Enrichment' + fig_file_name            plt.savefig(fig_file_address, dpi=300)            plt.close()    else:        enrichment_factors = []        ranks = []        for sequence_data in sorted_sequence_table:            enrichment_factors.append(sequence_data[Avg_enrichment_factor][0])            ranks.append(sequence_data[Avg_rank][0])        # make plot        fig, ax = plt.subplots(figsize=(6,4))        ax.plot(ranks, enrichment_factors, marker='o', linestyle='', markeredgewidth=0)        ax.grid(axis='y', color='0.5')        ax.set_xlabel('Rank')        ax.set_ylabel('Average enrichment factor')        ax.set_title('All selections')        plt.tight_layout        # Save        fig_file_name = '//Average enrichment factor vs rank .png'        fig_file_address = plot_folder + '//Enrichment' + fig_file_name        plt.savefig(fig_file_address, dpi=300)        plt.close()               print('> Binning')       '''Binning for pairing plots and motifs'''    ##working but no loop    #0.1 = 10%    bins = [0.0001, 0.0003, 0.001, 0.003, 0.01, 0.03, 0.1]    limits = []    category_labels = []    for p in bins:        n = int(p*len(paired_sequence_table)) + 1        if n >= 4:            limits.append(n)            category_labels.append('Top {:.2%}\n(n={:,})'.format(p, n))    limits.append(len(paired_sequence_table))    category_labels.append('All\n(n={:,})'.format(len(paired_sequence_table)))      print('> stacked bars by pair type')    for limit in limits[:-1]:        sequence_holder = []        for row in paired_sequence_table[:limit]:            sequence = row[Randomized_sequence][0].replace('/ ','')            sequence_holder.append(Seq(sequence,IUPAC.unambiguous_rna))        # stacked bar by pair type        pair_count_dict = {'GC':[0,0,0,0,0,0,0],                       'CG':[0,0,0,0,0,0,0],                       'AU':[0,0,0,0,0,0,0],                       'UA':[0,0,0,0,0,0,0],                       'GU':[0,0,0,0,0,0,0],                       'UG':[0,0,0,0,0,0,0]}        for sequence in sequence_holder:            for coords in [[0,13], [1,12], [2,11], [3,10], [4,9], [5,8], [6,7]]:                a, b = coords[0], coords[1]                pair_string = sequence[a] + sequence[b]                if pair_string in pair_count_dict:                    pair_count_dict[pair_string][a] += 1        pair_names = []        pair_count_list = []        for p in pair_count_dict:            pair_names.append(p)            pair_count_list.append(pair_count_dict[p])        fig, ax = stacked_bar_chart(['1', '2', '3', '4', '5', '6', '7'], pair_count_list,                                    Colors = ['black', 'b', 'g', 'y', 'orange', 'r'])        fig_file_name = 'Pair types ' + str(limit) + '.png'        fig_file_address = working_folder_name + '//Plots//Results//Base pairing//' + fig_file_name        ax.set_xlabel('Base Pair Postion')        ax.set_ylabel('# of Samples in Bin')        ax.set_title('Base Pair Per Postion')        plt.rcParams.update({'figure.autolayout': True})        plt.savefig(fig_file_address, dpi=300)        plt.close()    # Generate a table with only fully paired sequences    fully_paired_table = []    full_pairs = len(expected_pairs)    for row in paired_sequence_table:        if row[Paired_bases][0] == full_pairs:            fully_paired_table.append(row)    # Compare different selection runs    print('> Plotting selection comparisons')    # Pairwise compare all selections, sel_a_enrichment_factors vs sel_b_enrichment_factors    for i in range(1, len(biosamples)-1):        for j in range(i, len(biosamples)):            sel_a_data = []            sel_b_data = []            for sequence_data in sorted_sequence_table:                sel_a_data.append(sequence_data[Enrichment_factor][i])                sel_b_data.append(sequence_data[Enrichment_factor][j])            # make plot            fig, ax = plt.subplots(figsize=(5,5))            ax.plot(sel_a_data, sel_b_data, marker='o', linestyle='', markeredgewidth=0)            ax.grid(axis='y', color='0.5')            ax.set_xlabel(biosamples[i])            ax.set_ylabel(biosamples[j])            ax.set_title('Enrichment factors')            plt.tight_layout            # Save            fig_file_name = '//' + biosamples[i] + ' vs ' + biosamples[j] + '.png'            fig_file_address = plot_folder + '//Compare selections' + fig_file_name            plt.savefig(fig_file_address, dpi=300)            plt.close()